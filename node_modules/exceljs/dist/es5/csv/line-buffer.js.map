{"version":3,"sources":["../../../lib/csv/line-buffer.js"],"names":["events","require","utils","LineBuffer","module","exports","options","EventEmitter","call","encoding","buffer","corked","queue","inherits","write","chunk","data","lines","split","pop","forEach","line","push","emit","cork","uncork","_flush","setDefaultEncoding","end"],"mappings":"AAAA;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AAEA,IAAMC,KAAK,GAAGD,OAAO,CAAC,gBAAD,CAArB;;AAEA,IAAME,UAAU,GAAIC,MAAM,CAACC,OAAP,GAAiB,UAASC,OAAT,EAAkB;AACrDN,EAAAA,MAAM,CAACO,YAAP,CAAoBC,IAApB,CAAyB,IAAzB;AACA,OAAKC,QAAL,GAAgBH,OAAO,CAACG,QAAxB;AAEA,OAAKC,MAAL,GAAc,IAAd,CAJqD,CAMrD;;AACA,OAAKC,MAAL,GAAc,KAAd;AACA,OAAKC,KAAL,GAAa,EAAb;AACD,CATD;;AAWAV,KAAK,CAACW,QAAN,CAAeV,UAAf,EAA2BH,MAAM,CAACO,YAAlC,EAAgD;AAC9C;AACA;AACA;AAEAO,EAAAA,KAL8C,iBAKxCC,KALwC,EAKjC;AACX;AACA;AACA,QAAMC,IAAI,GAAG,KAAKN,MAAL,GAAc,KAAKA,MAAL,GAAcK,KAA5B,GAAoCA,KAAjD;AACA,QAAME,KAAK,GAAGD,IAAI,CAACE,KAAL,CAAW,QAAX,CAAd,CAJW,CAMX;;AACA,SAAKR,MAAL,GAAcO,KAAK,CAACE,GAAN,EAAd;AAEAF,IAAAA,KAAK,CAACG,OAAN,CAAc,UAASC,IAAT,EAAe;AAC3B,UAAI,KAAKV,MAAT,EAAiB;AACf,aAAKC,KAAL,CAAWU,IAAX,CAAgBD,IAAhB;AACD,OAFD,MAEO;AACL,aAAKE,IAAL,CAAU,MAAV,EAAkBF,IAAlB;AACD;AACF,KAND;AAQA,WAAO,CAAC,KAAKV,MAAb;AACD,GAvB6C;AAwB9Ca,EAAAA,IAxB8C,kBAwBvC;AACL,SAAKb,MAAL,GAAc,IAAd;AACD,GA1B6C;AA2B9Cc,EAAAA,MA3B8C,oBA2BrC;AACP,SAAKd,MAAL,GAAc,KAAd;;AACA,SAAKe,MAAL,GAFO,CAIP;;;AACA,SAAKH,IAAL,CAAU,OAAV;AACD,GAjC6C;AAkC9CI,EAAAA,kBAlC8C,gCAkCzB,CACnB;AACD,GApC6C;AAqC9CC,EAAAA,GArC8C,iBAqCxC;AACJ,QAAI,KAAKlB,MAAT,EAAiB;AACf,WAAKa,IAAL,CAAU,MAAV,EAAkB,KAAKb,MAAvB;AACA,WAAKA,MAAL,GAAc,IAAd;AACD;;AACD,SAAKa,IAAL,CAAU,MAAV;AACD,GA3C6C;AA6C9CG,EAAAA,MA7C8C,oBA6CrC;AACP,QAAI,CAAC,KAAKf,MAAV,EAAkB;AAChB,WAAKC,KAAL,CAAWQ,OAAX,CAAmB,UAASC,IAAT,EAAe;AAChC,aAAKE,IAAL,CAAU,MAAV,EAAkBF,IAAlB;AACD,OAFD;AAGA,WAAKT,KAAL,GAAa,EAAb;AACD;AACF;AApD6C,CAAhD","sourcesContent":["'use strict';\n\nconst events = require('events');\n\nconst utils = require('../utils/utils');\n\nconst LineBuffer = (module.exports = function(options) {\n  events.EventEmitter.call(this);\n  this.encoding = options.encoding;\n\n  this.buffer = null;\n\n  // part of cork/uncork\n  this.corked = false;\n  this.queue = [];\n});\n\nutils.inherits(LineBuffer, events.EventEmitter, {\n  // Events:\n  //  line: here is a line\n  //  done: all lines emitted\n\n  write(chunk) {\n    // find line or lines in chunk and emit them if not corked\n    // or queue them if corked\n    const data = this.buffer ? this.buffer + chunk : chunk;\n    const lines = data.split(/\\r?\\n/g);\n\n    // save the last line\n    this.buffer = lines.pop();\n\n    lines.forEach(function(line) {\n      if (this.corked) {\n        this.queue.push(line);\n      } else {\n        this.emit('line', line);\n      }\n    });\n\n    return !this.corked;\n  },\n  cork() {\n    this.corked = true;\n  },\n  uncork() {\n    this.corked = false;\n    this._flush();\n\n    // tell the source I'm ready again\n    this.emit('drain');\n  },\n  setDefaultEncoding() {\n    // ?\n  },\n  end() {\n    if (this.buffer) {\n      this.emit('line', this.buffer);\n      this.buffer = null;\n    }\n    this.emit('done');\n  },\n\n  _flush() {\n    if (!this.corked) {\n      this.queue.forEach(function(line) {\n        this.emit('line', line);\n      });\n      this.queue = [];\n    }\n  },\n});\n"],"file":"line-buffer.js"}