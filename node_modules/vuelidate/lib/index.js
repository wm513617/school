'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withParams = exports.validationMixin = exports.Vuelidate = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _params = require('./params');

var buildFromKeys = function buildFromKeys(keys, fn, keyFn) {
  return keys.reduce(function (build, key) {
    build[keyFn ? keyFn(key) : key] = fn(key);
    return build;
  }, {});
};

function isPromise(object) {
  return (typeof object === 'object' || typeof object === 'function') && typeof object.then === 'function';
}

var getPath = function getPath(ctx, obj, path, fallback) {
  if (typeof path === 'function') {
    return path.call(ctx, obj, fallback);
  }

  path = Array.isArray(path) ? path : path.split('.');
  for (var i = 0; i < path.length; i++) {
    if (obj && typeof obj === 'object') {
      obj = obj[path[i]];
    } else {
      return fallback;
    }
  }

  return typeof obj === 'undefined' ? fallback : obj;
};

function makePendingAsyncVm(Vue, promise) {
  var asyncVm = new Vue({
    data: {
      pending: true,
      value: false
    }
  });

  promise.then(function (value) {
    asyncVm.pending = false;
    asyncVm.value = value;
  }, function (error) {
    asyncVm.pending = false;
    asyncVm.value = false;
    throw error;
  });

  asyncVm.__isVuelidateAsyncVm = true;
  return asyncVm;
}

var validationGetters = {
  $invalid: function $invalid() {
    var proxy = this.proxy;
    return this.nestedKeys.some(function (nested) {
      return proxy[nested].$invalid;
    }) || this.ruleKeys.some(function (rule) {
      return !proxy[rule];
    });
  },
  $dirty: function $dirty() {
    if (this.dirty) {
      return true;
    }
    if (this.nestedKeys.length === 0) {
      return false;
    }

    var proxy = this.proxy;
    return this.nestedKeys.every(function (key) {
      return proxy[key].$dirty;
    });
  },
  $error: function $error() {
    return this.$dirty && !this.$pending && this.$invalid;
  },
  $pending: function $pending() {
    var _this = this;

    var proxy = this.proxy;
    return this.nestedKeys.some(function (key) {
      return proxy[key].$pending;
    }) || this.ruleKeys.some(function (key) {
      return _this.getRef(key).$pending;
    });
  },
  $params: function $params() {
    var _this2 = this;

    var vals = this.validations;
    return _extends({}, buildFromKeys(this.nestedKeys, function (key) {
      return vals[key] && vals[key].$params || null;
    }), buildFromKeys(this.ruleKeys, function (key) {
      return _this2.getRef(key).$params;
    }));
  }
};

function setDirtyRecursive(newState) {
  this.dirty = newState;
  var proxy = this.proxy;
  var method = newState ? '$touch' : '$reset';
  this.nestedKeys.forEach(function (key) {
    proxy[key][method]();
  });
}

var validationMethods = {
  $touch: function $touch() {
    setDirtyRecursive.call(this, true);
  },
  $reset: function $reset() {
    setDirtyRecursive.call(this, false);
  },
  $flattenParams: function $flattenParams() {
    var proxy = this.proxy;
    var params = [];
    for (var key in this.$params) {
      if (this.isNested(key)) {
        var childParams = proxy[key].$flattenParams();
        for (var j = 0; j < childParams.length; j++) {
          childParams[j].path.unshift(key);
        }
        params = params.concat(childParams);
      } else {
        params.push({ path: [], name: key, params: this.$params[key] });
      }
    }
    return params;
  }
};

var getterNames = Object.keys(validationGetters);
var methodNames = Object.keys(validationMethods);

var _cachedComponent = null;
var getComponent = function getComponent(Vue) {
  if (_cachedComponent) {
    return _cachedComponent;
  }

  var ValidationRule = Vue.extend({
    props: ['rule', 'model', 'parentModel', 'rootModel'],
    methods: {
      runRule: function runRule(parent) {
        // Avoid using this.parentModel to not get dependent on it.
        // Passed as an argument for workaround
        (0, _params.pushParams)();
        var rawOutput = this.rule.call(this.rootModel, this.model, parent);
        var output = isPromise(rawOutput) ? makePendingAsyncVm(Vue, rawOutput) : rawOutput;

        var rawParams = (0, _params.popParams)();
        var params = rawParams && rawParams.$sub ? rawParams.$sub.length > 1 ? rawParams : rawParams.$sub[0] : null;

        return { output: output, params: params };
      }
    },
    computed: {
      run: function run() {
        var _this3 = this;

        var parent = this.parentModel;
        var isArrayDependant = Array.isArray(parent) && parent.__ob__;

        if (isArrayDependant) {
          // force depend on the array
          var arrayDep = parent.__ob__.dep;
          arrayDep.depend();

          var target = arrayDep.constructor.target;

          if (!this._indirectWatcher) {
            var Watcher = target.constructor;
            this._indirectWatcher = new Watcher(this.rootModel, function () {
              return _this3.runRule(parent);
            }, null, { lazy: true });
          }

          // if the update cause is only the array update
          // and value stays the same, don't recalculate
          if (!this._indirectWatcher.dirty && this._lastModel === this.model) {
            this._indirectWatcher.depend();
            return target.value;
          }

          this._lastModel = this.model;
          this._indirectWatcher.evaluate();
          this._indirectWatcher.depend();
        }

        return this._indirectWatcher ? this._indirectWatcher.value : this.runRule(parent);
      },
      $params: function $params() {
        return this.run.params;
      },
      proxy: function proxy() {
        var output = this.run.output;
        if (output.__isVuelidateAsyncVm) {
          return !!output.value;
        }
        return !!output;
      },
      $pending: function $pending() {
        var output = this.run.output;
        if (output.__isVuelidateAsyncVm) {
          return output.pending;
        }
        return false;
      }
    },
    render: function render(h) {
      return null;
    }
  });

  var Validation = Vue.extend({
    data: function data() {
      return {
        dirty: false
      };
    },
    mounted: function mounted() {
      this._watcher.lazy = true;
    },

    props: ['validations', 'model', 'prop', 'parentModel', 'rootModel'],
    methods: _extends({}, validationMethods, {
      getRef: function getRef(key) {
        this._watcher.depend();
        if (this._watcher.dirty) {
          this._watcher.evaluate();
        }
        return this.$refs[key];
      },
      isNested: function isNested(key) {
        return typeof this.validations[key] !== 'function';
      }
    }),
    computed: _extends({}, validationGetters, {
      nestedKeys: function nestedKeys() {
        return this.keys.filter(this.isNested);
      },
      ruleKeys: function ruleKeys() {
        var _this4 = this;

        return this.keys.filter(function (k) {
          return !_this4.isNested(k);
        });
      },
      keys: function keys() {
        return Object.keys(this.validations);
      },
      proxy: function proxy() {
        var _this5 = this;

        var keyDefs = buildFromKeys(this.keys, function (key) {
          return {
            enumerable: true,
            configurable: false,
            get: function get() {
              return _this5.getRef(key).proxy;
            }
          };
        });

        var getterDefs = buildFromKeys(getterNames, function (key) {
          return {
            enumerable: true,
            configurable: false,
            get: function get() {
              return _this5[key];
            }
          };
        });

        var methodDefs = buildFromKeys(methodNames, function (key) {
          return {
            enumerable: false,
            configurable: false,
            get: function get() {
              return _this5[key];
            }
          };
        });

        return Object.defineProperties({}, _extends({}, keyDefs, getterDefs, methodDefs));
      }
    }),
    render: function render(h) {
      var _this6 = this;

      return h('div', [this.nestedKeys.map(function (key) {
        return renderNested(h, _this6, key);
      }), this.ruleKeys.map(function (key) {
        return renderRule(h, _this6, key);
      })]);
    }
  });

  var GroupValidation = Validation.extend({
    methods: {
      isNested: function isNested(key) {
        return typeof this.validations[key]() !== 'undefined';
      },
      getRef: function getRef(key) {
        var vm = this;
        return {
          get proxy() {
            // default to invalid
            return vm.validations[key]() || false;
          }
        };
      }
    },
    render: function render() {
      return null;
    }
  });

  var EachValidation = Validation.extend({
    computed: {
      keys: function keys() {
        return Object.keys(this.model);
      },
      tracker: function tracker() {
        var _this7 = this;

        var trackBy = this.validations.$trackBy;
        return trackBy ? function (key) {
          return '' + getPath(_this7.rootModel, _this7.model[key], trackBy);
        } : function (x) {
          return '' + x;
        };
      }
    },
    methods: {
      isNested: function isNested() {
        return true;
      },
      getRef: function getRef(key) {
        this._watcher.depend();
        if (this._watcher.dirty) {
          this._watcher.evaluate();
        }
        return this.$refs[this.tracker(key)];
      }
    },
    render: function render(h) {
      return h('div', renderEach(h, this));
    }
  });

  var renderNested = function renderNested(h, vm, key) {
    if (key === '$params') {
      return null;
    }
    if (key === '$each') {
      return h(EachValidation, {
        key: key,
        ref: key,
        attrs: {
          validations: vm.validations[key],
          parentModel: vm.parentModel,
          prop: key,
          model: vm.model,
          rootModel: vm.rootModel
        }
      });
    }
    var validations = vm.validations[key];
    if (Array.isArray(validations)) {
      var root = vm.rootModel;
      var refVals = buildFromKeys(validations, function (path) {
        return function () {
          return getPath(root, root.$v, path);
        };
      }, function (v) {
        return Array.isArray(v) ? v.join('.') : v;
      });
      return h(GroupValidation, {
        key: key,
        ref: key,
        attrs: {
          validations: refVals,
          parentModel: null,
          prop: key,
          model: null,
          rootModel: root
        }
      });
    }
    return h(Validation, {
      key: key,
      ref: key,
      attrs: {
        validations: validations,
        parentModel: vm.model,
        prop: key,
        model: vm.model[key],
        rootModel: vm.rootModel
      }
    });
  };

  var renderEach = function renderEach(h, vm) {
    var def = vm.validations;

    var validations = _extends({}, def);
    delete validations['$trackBy'];

    var usedTracks = {};

    return vm.keys.map(function (key) {
      var track = vm.tracker(key);
      if (usedTracks.hasOwnProperty(track)) {
        return null;
      }
      usedTracks[track] = true;
      return h(Validation, {
        key: track,
        ref: track,
        attrs: {
          validations: validations,
          prop: key,
          parentModel: vm.model,
          model: vm.model[key],
          rootModel: vm.rootModel
        } });
    });
  };

  var renderRule = function renderRule(h, vm, key) {
    return h(ValidationRule, { key: key,
      ref: key,
      attrs: {
        rule: vm.validations[key],
        parentModel: vm.parentModel,
        model: vm.model,
        rootModel: vm.rootModel
      } });
  };

  _cachedComponent = Validation;
  return _cachedComponent;
};

var _cachedVue = null;
function getVue(rootVm) {
  if (_cachedVue) return _cachedVue;
  var Vue = rootVm.constructor;
  /* istanbul ignore next */
  while (Vue.super) {
    Vue = Vue.super;
  }_cachedVue = Vue;
  return Vue;
}

var validateModel = function validateModel(model, validations) {
  var Vue = getVue(model);
  var Validation = getComponent(Vue);
  var root = new Vue({
    render: function render(h) {
      var vals = typeof validations === 'function' ? validations.call(model) : validations;

      return h(Validation, {
        ref: '$v',
        attrs: {
          validations: vals,
          parentModel: null,
          prop: '$v',
          model: model,
          rootModel: model
        }
      });
    }
  });
  root.$mount();
  return root;
};

var validationMixin = {
  beforeCreate: function beforeCreate() {
    var _this8 = this;

    var options = this.$options;
    var vals = options.validations;
    if (!vals) return;
    if (!options.computed) options.computed = {};
    options.computed.$v = function () {
      return _this8._vuelidate.$refs.$v.proxy;
    };
  },
  created: function created() {
    var vals = this.$options.validations;
    if (vals) {
      this._vuelidate = validateModel(this, vals);
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this._vuelidate) {
      this._vuelidate.$destroy();
      this._vuelidate = null;
    }
  }
};

function Vuelidate(Vue) {
  Vue.mixin(validationMixin);
}

exports.Vuelidate = Vuelidate;
exports.validationMixin = validationMixin;
exports.withParams = _params.withParams;
exports.default = Vuelidate;