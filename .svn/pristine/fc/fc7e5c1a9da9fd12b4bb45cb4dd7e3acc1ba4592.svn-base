<template>
  <div class="video-plugin" :class="[isFullScreen ? 'fs' : '']">
    <div class="single-video-plugin" ref="singleVideo" :style="{ height: isButton ? `calc(100% - ${configuration.timeline ? configuration.timeline.isMultistage ? 170 + 56 : 100 + 56 : 56 }px)` : '100%' }">
      <plugin ref="plugin"  v-for="(item, index) in panesArr[panesArr.length-1].value" :key="index" :paneMark="index" :style="{width: (isMaximize&&index===checkedPane) ? '100%' : pluginSize[index].w, height: (isMaximize&&index===checkedPane) ? '100%' : pluginSize[index].h, padding: '1px'}" :class="className(index)" :singleStatus="videoStatusArr[index]" @middlePlay="middlePlay" @clickEvent="clickEvent" @updateStatus="updateStatus"></plugin>
    </div>
    <div class="video-bottom" v-if="isButton">
      <div class="left">
        <!-- <button @click="kk">ceshi</button> -->
        <i class="icon iconfont" :class="[iconPlay , selectedObj.playStatus || isSync ? '' : 'disabled']" :title="[selectedObj.isPlay? '暂停': '播放']" @click="playStop"></i>
        <i class="icon iconfont icon-stop" :class="[!selectedObj.playStatus || !selectedObj.isPlay ? 'disabled' : '']" @click="stop(checkedPane, true)" title="停止" v-if="!buttos.includes('stop')"></i>
        <i class="icon iconfont icon-stop-all" :class="[stopStatus? 'disabled' : '']" @click="stop()" title="停止全部" v-if="!buttos.includes('stopAll')"></i>
        <i class="icon iconfont icon-xiazai" :class="[!selectedObj.isPlay || selectedObj.dumpHandle !== '' ? 'disabled' : '']" title="下载" @click="openDownload" v-if="!buttos.includes('xiazai')"></i>
        <i class="icon iconfont icon-screenshot" :class="[!selectedObj.isPlay ? 'disabled' : '']" v-if="!buttos.includes('screenshot')" title="截图" @click="getCapture"></i>
        <i class="icon iconfont icon-tv-wall" :class="[!selectedObj.isPlay ? 'disabled' : '']" title="快速上墙" v-if="!buttos.includes('onTheWall')" @click="toWallBtn"></i>
        <i class="icon iconfont icon-full-screen" v-if="!isFullScreen && !buttos.includes('screen')" title="全屏" @click="fullScreen"></i>
        <i class="icon iconfont icon-exit-full-screen" v-if="isFullScreen && !buttos.includes('screen')" title="退出全屏" @click="escScreen"></i>
        <i class="icon iconfont" :class="[selectedObj.showVolume&&selectedObj.isPlay? 'icon-volume': 'icon-mute', !selectedObj.isPlay ? 'disabled' : '']" v-if="!buttos.includes('volume')" title="音量调节" @click="volumeSwitch"></i>
        <div style="width:80px;display:inline-block;vertical-align:super;height:20px" v-if="selectedObj.showVolume">
          <Slider color="#20a1ff" :value="selectedObj.volumeValue" :tip-format="sliderFormat" @on-change="changeVolume"></Slider>
        </div>
      </div>
      <div class="right" v-if="configuration.progressBar">
        <div class="progress-bar">
          <span class="play-time"  v-if="!configuration.progressBar.totalTime">{{$moment(playTime * 1000).format('YYYY-MM-DD HH:mm:ss')}}</span>
          <span class="occurrence-time" v-show="selectedObj.result.occurrenceTime" :style="{'left': occurrenceTimeLeft + '%'}"></span>
          <div class="total-time" v-if="configuration.progressBar.totalTime">
            <span>{{progressNow}} / {{progressTotalTime}}</span>
          </div>
          <div class="slide-mon-f">
            <!-- <Slider class="slide-mon" :disabled="!selectedObj.isPlay" :value="progress" @on-change="sliderChange" :tip-format="sliderFormat"></Slider> -->
            <Slider class="slide-mon" :value="progress" @on-change="sliderChange" :tip-format="sliderFormat"></Slider>
          </div>
        </div>
      </div>
      <div class="right" v-if="!configuration.progressBar">
        <div class="dp-con showmodeShow" @mouseenter="showmodeShow=true" @mouseleave="showmodeShow=false" v-if="!buttos.includes('showmodeShow')">
          <i class="icon iconfont icon-multi-screen"  title="画面分割"></i>
          <ul v-show="showmodeShow" class="showmode-list">
            <i></i>
            <li v-for="mode in panesArr" :key='mode.value' @click="clickCheckedWmode(mode)" :class="{active: mode.value===checkedWmode}">{{mode.label}}</li>
          </ul>
        </div>
        <!-- <i class="icon iconfont icon-full-screen" title="全屏" @click="fullScreen"></i> -->
      </div>
    </div>
    <div class="video-timeline" v-if="configuration.timeline" :style="{height: configuration.timeline.isMultistage ? '170px' : '100px'}">
      <div class="one-stage">
        <div class="timeline-stage-top">
          <div class="stage-top-right">
            <div class="period">
              <i class="icon iconfont icon-large" :class="[interval === 0 ? 'disabled' : '']" @click="intervalChange(1)"></i>
              <span>{{intervalArr[interval].label}}</span>
              <i class="icon iconfont icon-small" :class="[interval >= intervalArr.length - 1 ? 'disabled' : '']" @click="intervalChange(0)"></i>
            </div>
          </div>
          <span class="play-time">{{$moment(this.playTime * 1000).format('YYYY-MM-DD HH:mm:ss')}}</span>
        </div>
        <div class="timeline-stage-bottom">
          <div class="timeline-scale">
            <div class="pointer">
              <div class="pointer-line"></div>
            </div>
            <canvas id="time-scale"></canvas>
          </div>
          <div class="timeline-video-segments">
            <div class="segments">
              <div class="segments-son" v-for="(item, index) in singleStage" :key="index" :style="{left: item.left, width: item.width, backgroundColor: item.bgc}"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <Modal class="quickTowall" v-model="showWall" title="快速上墙" :mask-closable="false" :transition-names="[]">
      <iframe v-if="showWall" style="z-index:0;position: absolute;border: 0 none;top: 0;left: 0; width: 100%; height: 100%;"></iframe>
      <QuickToWall v-if="showWall" ref="toWall"  @checkWall="checkWall" :isPlayback="true" style="position:relative;" :camera="selectedObj.result.resId"></QuickToWall>
      <div slot="footer" style="position:relative">
        <Button type="ghost" @click="showWall=false">关闭</Button>
      </div>
    </Modal>
  </div>
</template>
<script>
import plugin from './plugin'
import { mapState, mapActions } from 'vuex'
import { openPlaybackList, stopRecordPlay, downloadVideoSegments, checkVideoList, videoFilter } from './playback.js'
import { timerShaft } from './timershaft.js' // 时间轴刻度
import QuickToWall from 'view/video/tvwall/QuickToWall'
export default {
  components: {
    plugin,
    QuickToWall
  },
  props: {
    panesArr: {
      type: Array,
      default: () => [
        { value: 1, label: '单画面' },
        { value: 4, label: '四画面' },
        { value: 9, label: '九画面' },
        { value: 16, label: '十六画面' }
      ]
    },
    isButton: {
      // 视频窗下方总按钮条
      type: Boolean,
      default: true
    },
    defaultPane: {
      // 默认显示窗格数量
      type: Number,
      default: 4
    },
    configuration: {
      // 配置项
      type: Object,
      default: () => {
        return {
          // progressBar: false, // 进度条
          progressBar: {
            totalTime: true
          }, // 进度条
          // timeline: false
          timeline: {
            // 时间轴配置项
            isMultistage: false
          },
          // buttos: ['stopAll', 'onTheWall'] // 数组有的按钮都不显示  onTheWall: 上墙，stopAll：全部关闭, showmodeShow:多画面, stop: 停止按钮， xiazai：下载按钮， screenshot：截图按钮， screen：全屏， volume：音量
          buttos: []
        }
      }
    },
    windowAdapter: {
      // 窗口适配参数
      type: Array,
      default: () => []
    }
  },
  computed: {
    ...mapState({
      parameters: ({ platform }) => platform.parameters
    }),
    pluginSize() {
      // 各个视频框大小数组
      let arr = []
      if ([1, 4, 9, 16].includes(this.checkedWmode)) {
        for (let index = 0; index < this.panesArr[this.panesArr.length - 1].value; index++) {
          arr.push({ w: `${100 / Math.sqrt(this.checkedWmode)}%`, h: `${100 / Math.sqrt(this.checkedWmode)}%` })
        }
      }
      return arr
    },
    selectedObj() {
      // 选中项状态值
      return this.videoStatusArr[this.checkedPane]
    },
    stopStatus() {
      // 全部停止样式判断
      let status = true
      for (const iterator of this.videoStatusArr) {
        if (iterator.playStatus) {
          status = false
          break
        }
      }
      return status
    },
    iconPlay() {
      let icon = ''
      if (this.isSync) {
        for (let index = 0; index < this.videoStatusArr.length; index++) {
          const element = this.videoStatusArr[index]
          if (element.isPlay) {
            icon = 'icon-pause'
            break
          }
          if (index === this.videoStatusArr.length - 1) {
            icon = 'icon-play'
          }
        }
      } else {
        icon = this.selectedObj.isPlay ? 'icon-pause' : 'icon-play'
      }
      return icon
    },
    buttos() {
      let arr = []
      if (this.configuration.buttos) {
        arr = this.configuration.buttos
      }
      return arr
    }
  },
  data() {
    return {
      isFullScreen: false, // 是否使用全屏
      isSync: false, // 是否是同步回放
      checkedPane: 0, // 当前选中视频框的index
      showmodeShow: false, // 窗格配置显示
      checkedWmode: this.defaultPane, // 当前窗格数量
      isMaximize: false, // 单画面
      videoStatusArr: [], // 视频窗格状态数组
      showWall: false, // 上墙弹窗状态
      //  进度条变量 start
      progress: 0, // 进度条进度
      progressTimer: null, // 进度条定时器
      isOperation: false, // 进度条是否被操作
      playTime: new Date().getTime() / 1000, // 回放视频当前时间
      occurrenceTimeLeft: 0, // 进度条标记时间
      progressTotalTime: '00:00:00',
      progressNow: '00:00:00',
      // 进度条变量end
      // 时间轴变量start
      // intervalArr: ['24h', '12h', '1h', '30min', '10min'], // 时间轴周期数组 ['1m', '12m', '30m', '1h', '3h', '6h', '12h', '24h']
      intervalArr: [
        { value: 24 * 3600, label: '24h' },
        { value: 12 * 3600, label: '12h' },
        { value: 3 * 3600, label: '3h' },
        { value: 3600, label: '1h' },
        { value: 30 * 60, label: '30min' },
        { value: 12 * 60, label: '12min' },
        { value: 60, label: '1min' }
      ], // 时间轴周期数组
      interval: 0, // 时间轴周期项
      middleTime: new Date().getTime() / 1000, // 时间轴中间时间
      timePeriod: 24 * 3600, // 时间轴周期 单位 秒
      singleStage: [], // 单个时间轴上标记多段录像段数组
      colorArr: [
        '#990033',
        '#FF3366',
        '#006699',
        '#FF6600',
        '#CC3333',
        '#FFCC99',
        '#FF0000',
        '#00CC99',
        '#339933',
        '#33CC33',
        '#33CC00',
        '#999966',
        '#CCCCCC',
        '#CCFFFF',
        '#669966',
        '"#666FF"'
      ],
      // 时间轴变量 end
      middlePlayFatherStatus: false, // 停止后 是否需要窗格中间播放按钮
      playOverCallback: () => {} // 窗格播放完毕的回调

    }
  },
  created() {
    this.initializeArr()
  },
  mounted() {
    // 进度条监听事件 start
    if (this.configuration.progressBar) {
      let sliderDom = document.querySelector('.slide-mon')
      document.onmouseup = e => {
        this.isOperation = false
      }
      sliderDom.onmousedown = e => {
        this.isOperation = true
      }
    }
    // 进度条监听 end
    // 时间轴 start
    this.$nextTick(() => {
      this.initTimerShaft()
    })
    // 时间轴 end
    // 键盘事件监听
    document.onkeydown = e => {
      if (e.keyCode === 27) {
        this.escScreen()
      }
    }
    window.onresize = e => {
      let isFull =
        document.fullscreenEnabled ||
        window.fullScreen ||
        document.webkitIsFullScreen ||
        document.msFullscreenEnabled ||
        false
      if (!isFull) {
        // 退出全屏后要执行的动作
        this.escScreen()
      }
    }
  },
  methods: {
    ...mapActions(['getVideoConf', 'getMonitorList', 'getTVList']),
    kk() {
      let arr = [
        // {
        //   name: '20.36',
        //   channel: 1,
        //   devIp: '192.168.14.123',
        //   devPort: 8000,
        //   endTime: 1565020800,
        //   eventType: ['all'],
        //   // startTime: 1563897600,1563972653
        //   startTime: 1564934400,
        //   streamType: 'main',
        //   occurrenceTime: 1564372200
        // },
        {
          name: '20.36',
          channel: 1,
          devIp: '192.168.20.36',
          devPort: 3721,
          endTime: 1565193600,
          eventType: ['all'],
          // startTime: 1563897600,1563972653
          startTime: 1565107200,
          streamType: 'main',
          // occurrenceTime: 1565150400,
          resId: '5c26d593cc13923fd8aa59e2',
          videoSegmentsIndex: 0 // 指定播放录像段索引
        },
        {
          name: '20.44',
          channel: 1,
          devIp: '192.168.20.44',
          devPort: 80,
          endTime: 1565193600,
          eventType: ['all'],
          // startTime: 1563897600,1563972653
          startTime: 1565107200,
          streamType: 'main',
          occurrenceTime: 1564980420,
          resId: '5c26d593cc13923fd8aa59e2'
        },
        // {
        //   name: '192.168.78.53',
        //   channel: 1,
        //   devIp: '192.168.78.53',
        //   devPort: 3721,
        //   endTime: 1565020800,
        //   eventType: ['all'],
        //   // startTime: 1563897600,1563972653
        //   startTime: 1564934400,
        //   streamType: 'main',
        //   occurrenceTime: 1564358400
        // },
        {
          name: '20.42',
          channel: 1,
          devIp: '192.168.20.42',
          devPort: 3721,
          endTime: 1565020800,
          eventType: ['all'],
          // startTime: 1563897600,1563972653
          startTime: 1564934400,
          streamType: 'main',
          occurrenceTime: 1564358400,
          resId: '5c26d593cc13923fd8aa59e2'
        }
      ]
      this.openPlayback(arr)
      // this.openSyncPlayback(arr)
      // 下载示例
      this.getVideoConf()
      // batchDownloadVideoSegments(arr, this.parameters).then(res => {
      //   console.log(res, 'ssssss')
      // }).catch(err => {
      //   console.log(err, 'slsls')
      // })
    },
    escScreen() {
      this.isFullScreen = false
      this.exitFullscreen()
      this.$nextTick(() => {
        this.initTimerShaft()
      })
    },
    fullScreen() {
      // if (!this.selectedObj.isPlay) {
      //   return
      // }
      this.isFullScreen = true
      this.requestFullscreen()
      // 重绘时间轴
      this.$nextTick(() => {
        this.initTimerShaft()
      })
    },
    getCapture() {
      // 截图
      if (!this.selectedObj.isPlay) {
        return
      }
      this.$refs.plugin[this.checkedPane].getCapture()
    },
    volumeSwitch() {
      // 音量开关
      if (!this.selectedObj.isPlay) {
        return
      }
      if (this.selectedObj.showVolume) {
        this.$refs.plugin[this.checkedPane].closeSound()
      } else {
        for (let index = 0; index < this.defaultPane; index++) {
          // 关闭所有音量
          if (this.videoStatusArr[index].showVolume) {
            this.$refs.plugin[index].closeSound()
          }
        }
        this.$refs.plugin[this.checkedPane].openSound()
        this.$refs.plugin[this.checkedPane].setSoundValue(50)
        let soundStatue = this.$refs.plugin[this.checkedPane].getSoundValue()
        if (soundStatue.success) {
          let objVolumeValue = { volumeValue: soundStatue.Volume }
          this.updateStatus(this.checkedPane, objVolumeValue)
        } else {
          this.$Notice.warning({ title: '警告', desc: '音量获取失败！' })
        }
      }
    },
    changeVolume(v) {
      // 设置音量大小
      if (!this.selectedObj.isPlay) {
        return
      }
      this.$refs.plugin[this.checkedPane].setSoundValue(v)
    },
    findStrmInfo(eventList, time) {
      // 找出当前播放录像段的strminfo
      for (const iterator of eventList) {
        if (iterator.evtTblInfo.startTime < time < iterator.evtTblInfo.endTime) {
          return iterator.strmInfo
        }
      }
    },
    matchingPane(number) {
      // 匹配窗格数量
      if (number === 1) {
        this.checkedWmode = 1
      } else if (number > 1 && number <= 4) {
        this.checkedWmode = 4
      } else if (number > 4 && number <= 9) {
        this.checkedWmode = 9
      } else {
        this.checkedWmode = 16
      }
    },
    // 快速上墙
    async checkWall(i) {
      // if (!this.isasyn) {
      //   return
      // }
      // console.log('checkWall', i)
      let eventList, ds, streamId, ts
      // const cutTime = JSON.parse(this.plugin.getPlayerCurTime())
      // if (!cutTime.success) {
      //   return
      // }
      // if (this.isNVR) {
      // const nvrOpenRes = await this.$parent.nvrVodOpen({ time: cutTime.msCur / 1000 })
      // ts = {
      //   tsPort: nvrOpenRes.TsPort,
      //   tsIp: nvrOpenRes.TsIp
      // }
      // streamId = nvrOpenRes.streamId
      // } else if (this.state.streamId) {
      // const gbOpenRes = await this.$parent.gbVodOpen({ time: cutTime.msCur / 1000 })
      // ts = {
      //   tsPort: gbOpenRes.TsPort,
      //   tsIp: gbOpenRes.TsIp
      // }
      // streamId = gbOpenRes.streamId
      // } else {
      // 中心回放上墙吧
      // this.activePluginData = this.$lodash.cloneDeep(this.resourceList[this.plugin.activedIndex])
      // const event = this.findStrmInfo(this.activePluginData.eventList, parseInt(cutTime.msCur / 1000))
      ds = {
        dsIp: this.selectedObj.result.dsIp,
        dsPort: 9000
      }
      eventList = {
        timeInfo: {
          startTime: parseInt(this.playTime),
          endTime: parseInt(this.selectedObj.result.endTime)
        },
        strmInfo: this.findStrmInfo(this.selectedObj.result.eventList, this.playTime)
      }
      eventList = {
        params: {
          jsonrpc: '2.0',
          id: '1',
          method: 'brest',
          call: 'AV.Record.playopen',
          args: {
            eventList: eventList
          }
        }
        // }
      }
      this.$refs.toWall.addToWall(this.selectedObj.result.resId, i, eventList, ds, streamId, ts).then(r => {
        // this.wallData[this.plugin.activedIndex] = r.data
      })
    },
    toWallBtn() {
      // 上墙
      if (!this.selectedObj.isPlay) {
        return
      }
      this.getTVList().then(() => {
        this.getMonitorList()
      })
      this.showWall = true
    },
    formatTime(time) {
      let h = Math.floor(time / 3600)
      let m = Math.floor((time % 3600) / 60)
      let s = Math.floor((time % 3600) % 60)
      return `${h < 10 ? String(0) + String(h) : h}:${m < 10 ? String(0) + String(m) : m}:${
        s < 10 ? String(0) + String(s) : s
      }`
    },
    pluginDom(index) {
      // 返回指定窗格的 object dom
      return index === undefined
        ? this.$refs.plugin[this.findFreePane()].$refs.object
        : this.$refs.plugin[index].$refs.object
    },
    initializeArr() {
      // 初始化窗格状态数组
      let arr = []
      for (let index = 0; index < 16; index++) {
        let obj = {
          isPlugin: true, // 是否使用插件 千万别删
          playStatus: false, // 插件是否加载
          isButton: false, // 小窗格上是否需要按钮条
          isPlay: false, // 是否播放
          result: {}, // 回放录像段信息
          dumpHandle: '', // 录像下载句柄 有就正在下载，页面切换后无效
          isSyncPlay: false, // 同步播放用来遮罩视频框的 显示黑色
          showVolume: false, // 是否显示音量滑块
          volumeValue: 50, // 音量值
          img: '', // 遮盖图片 Base64
          isMiddlePlay: false // 画面中间播放按钮
        }
        arr.push(obj)
      }
      this.videoStatusArr = arr
    },
    clickCheckedWmode(mode) {
      // 画面切换将选中项及是否单画面置为初始值
      let obj = document.querySelector('.single-video-plugin')
      obj.style.opacity = '0'
      this.checkedWmode = mode.value
      this.isMaximize = false
      this.checkedPane = 0
      setTimeout(() => {
        obj.style.opacity = '1'
      }, 800)
    },
    className(index) {
      // plugin 类名逻辑
      let obj = {}
      obj.hide = this.isMaximize ? index !== this.checkedPane : index + 1 > this.checkedWmode
      obj.active = this.checkedPane === index
      return obj
    },
    playStop() {
      // 播放暂停
      // this.isPlay = !this.isPlay
      if (this.isSync) {
        let status = this.iconPlay === 'icon-play'
        if (status) {
          // 同步关闭时要关闭定时器
          this.syncTime()
        } else {
          window.clearInterval(this.progressTimer)
        }
        for (let index = 0; index < this.videoStatusArr.length; index++) {
          const element = this.videoStatusArr[index]
          if (element.playStatus) {
            this.updateStatus(index, { isPlay: status })
            stopRecordPlay(this.pluginDom(index), status)
          }
        }
        return
      }
      if (!this.selectedObj.playStatus) {
        return
      } // 未开启画面的不予许点击
      // let recordPlayerCurTime = checkedResult.dsServerId ? JSON.parse(this.pluginDom(this.checkedPane).GetSpeechPlayerCurTime()) : JSON.parse(this.pluginDom(this.checkedPane).GetRecordPlayerCurTime())
      let playStatus = false
      let checkedResult = this.videoStatusArr[this.checkedPane].result
      try {
        let recordTime = {}
        if (checkedResult.dsServerId) {
          recordTime = JSON.parse(this.pluginDom(this.checkedPane).GetSpeechPlayerCurTime())
        } else {
          recordTime = JSON.parse(this.pluginDom(this.checkedPane).GetRecordPlayerCurTime())
        }
        if (recordTime.success) {
          playStatus = false
        } else {
          playStatus = true
        }
      } catch (err) {
        playStatus = false
      }
      if (
        !this.selectedObj.isPlay &&
        this.selectedObj.playStatus &&
        Object.keys(this.selectedObj.result).length !== 0 &&
        playStatus
      ) {
        // 该录像为放完了， 当点击播放时 重头开始放
        this.$emit('playStatus', 3) // 3是播放
        this.anewOpenPlayback('', true)
        this.timer()
        return
      }
      if (this.selectedObj.isPlay) {
        // 发出暂停事件
        this.$emit('playStatus', 1) // 1是暂停，2是停止
      } else {
        this.$emit('playStatus', 3) // 3是播放
      }
      this.updateStatus(this.checkedPane, { isPlay: !this.selectedObj.isPlay })
      stopRecordPlay(this.pluginDom(this.checkedPane), this.selectedObj.isPlay)
    },
    clickEvent(index, clickType, paneMark) {
      // 返回参数 index：插件窗格号 clicktype：单机还是双击
      // 点击事件
      this.checkedPane = paneMark
      if (clickType === 2) {
        let obj = document.querySelector('.single-video-plugin')
        obj.style.opacity = '0'
        this.isMaximize = this.checkedWmode !== 1 && !this.isMaximize // 单窗格不允许切换单画面
        setTimeout(() => {
          obj.style.opacity = '1'
        }, 800)
      }
      this.$emit('clickEvent', clickType, paneMark)
    },
    updateStatus(index, obj, type) {
      // 跟新视频窗格上的功能条  回放不需要窗格下的小进度条
      // if (type === 'isButton') {
      //   this.videoStatusArr.forEach(element => {
      //     element.isButton = false
      //   })
      // }
      // 子组件更新状态数组
      for (const key in obj) {
        if (key === 'isButton') {
          continue
        }
        this.videoStatusArr[index][key] = obj[key]
      }
    },
    findFreePane() {
      // 找出空闲窗格返回窗格索引
      for (let index = 0; index < this.checkedWmode; index++) {
        if (!this.videoStatusArr[index].playStatus) {
          return index
        }
      }
      return this.checkedPane
    },
    stop(index, playStatus = false) {
      try {
        // 没有index 就关闭全部
        if (index !== undefined) {
          if (this.isSync && !playStatus) {
            // 同步回放时停止全部
            this.stop()
            this.isSync = false
            return
          }
          this.videoStatusArr[index].playStatus && this.pluginDom(index).CloseRecordPlay()
          if (index === this.checkedPane) {
            // 停止后播放时间改为0
            this.progressNow = this.formatTime(0)
          }
          this.$emit('playStatus', 2) // 1是暂停，2是停止
          this.updateStatus(index, { isPlay: false, playStatus: playStatus })
          if (this.middlePlayFatherStatus) {
            // 显示窗格中间按钮
            this.updateStatus(index, {isSyncPlay: true, isMiddlePlay: true})
          }
          if (!this.isSync) {
            // 不是同步回放再停止定时器
            window.clearInterval(this.progressTimer)
            this.progress = 0
          }
          return
        }
        for (let i = 0; i < this.videoStatusArr.length; i++) {
          if (i === this.checkedPane) {
            // 停止后播放时间改为0
            this.progressNow = this.formatTime(0)
          }
          this.videoStatusArr[i].playStatus && this.pluginDom(i).CloseRecordPlay()
          this.$emit('playStatus', 2) // 1是暂停，2是停止
          this.updateStatus(i, { isPlay: false, playStatus: playStatus, result: {}, isSyncPlay: false })
        }
        window.clearInterval(this.progressTimer)
        this.progress = 0
      } catch (err) {
        console.log(err, '回放组件报错捕捉')
      }
    },
    middlePlay(paneMark) {
      // 窗格中间播放按钮回调
      // paneMark 窗格号
      if (this.middlePlayFatherStatus) {
        this.updateStatus(paneMark, {isSyncPlay: false, isMiddlePlay: false})
        console.log(paneMark, 'ppppp')
        this.anewOpenPlayback('', true, paneMark)
      }
      this.$emit('middlePlay', paneMark)
    },
    async openSyncPlayback(data, isQuery = true) {
      this.matchingPane(data.length)
      data = JSON.parse(JSON.stringify(data)) // 拷贝数据防止更改数据报错
      this.isSync = true
      this.stop(undefined, true)
      // 同步回放
      let playbackNumber = data.length
      if (data.length > this.checkedWmode) {
        this.errorMsg('无空闲窗口显示更多通道！')
        playbackNumber = this.checkedWmode
      }
      let videoList = []
      for (let index = 0; index < playbackNumber; index++) {
        videoList.push(checkVideoList(data[index]))
      }
      Promise.all(videoList)
        .then(res => {
          for (let index = 0; index < res.length; index++) {
            const element = res[index]
            if (typeof element.data !== 'object' || element.data.result.eventList.length === 0) {
              continue
            }
            this.updateStatus(index, { isPlugin: true, playStatus: true, isButton: false, isPlay: false }) // 提前加载插件 同步回放
            let filterList = JSON.parse(JSON.stringify(videoFilter(element.data.result, data[index])))
            filterList.newStartTime = filterList.eventList[0].evtTblInfo.startTime
            filterList.name = data[index].name
            filterList = Object.assign(JSON.parse(JSON.stringify(data[index])), filterList)
            this.updateStatus(index, { result: filterList })
          }
          // 找一个时间最早的
          let oneIndex = ''
          // 找一个结束时间最晚的
          let lateTime = ''
          for (let index = 0; index < this.videoStatusArr.length; index++) {
            let result = this.videoStatusArr[index].result
            if (Object.keys(result).length === 0 || result.eventList.length === 0) {
              continue
            }
            if (oneIndex === '') {
              oneIndex = index
              lateTime = result.endTime
              continue
            }
            if (
              result.eventList[0].evtTblInfo.startTime <
              this.videoStatusArr[oneIndex].result.eventList[0].evtTblInfo.startTime
            ) {
              oneIndex = index
            }
            if (result.endTime > lateTime) {
              lateTime = result.endTime
            }
          }
          // 找匹配的时间间距
          let interval = lateTime - this.videoStatusArr[oneIndex].result.startTime
          let spaceIndex = 0 // 默认使用最大间距
          for (let index = 0; index < this.intervalArr.length; index++) {
            const element = this.intervalArr[index].value
            if (interval <= element && element < this.intervalArr[spaceIndex].value) {
              spaceIndex = index
            }
          }
          this.intervalChange(null, spaceIndex) // 重新绘制时间轴
          this.openPlayback([this.videoStatusArr[oneIndex].result], false, oneIndex)
        })
        .catch(err => {
          this.errorMsg('录像查询失败！')
          console.log(err, '同步录像查询失败')
        })
    },
    syncPlaybackMaintain() {
      let judgeScope = (eventList, time) => {
        // 判断当前时间是否在录像段中
        for (let index = 0; index < eventList.length; index++) {
          const element = eventList[index]
          if (element.evtTblInfo.startTime <= time && time <= element.evtTblInfo.endTime) {
            return 1
          }
        }
        return 0
      }
      // 同步回放维持播放状态 在定时器触发过程中， 若有当前窗格时间段就开是播放
      this.$nextTick(() => {
        for (let index = 0; index < this.videoStatusArr.length; index++) {
          const element = this.videoStatusArr[index]
          if (Object.keys(element.result).length === 0 || element.result.eventList.length === 0) {
            continue
          }
          if (judgeScope(element.result.eventList, this.playTime) && !element.isPlay) {
            // 录像段在当前时间且没有播放 则开始播放
            this.updateStatus(index, { isSyncPlay: false }) // 去掉黑色遮罩
            // console.log(this.playTime, '去掉黑色', index)
            this.anewSyncOpenPlayback(this.playTime, index)
          }
          // 加上黑色遮罩
          if (!judgeScope(element.result.eventList, this.playTime) && element.playStatus) {
            // 当前时间没在录像段 则关闭录像并遮盖
            // console.log(this.playTime, '加上黑色', index)
            this.updateStatus(index, { isSyncPlay: true })
            // 停止传 true 让不要销毁object标签
            this.stop(index, true)
          }
        }
      })
    },
    async anewSyncOpenPlayback(newTime, index) {
      // 同步重新开流
      if (index === undefined) {
        // 不传index 就全部重新开流 不能全部重开 只能开开过的 这是同步
        for (let i = 0; i < this.videoStatusArr.length; i++) {
          if (!this.videoStatusArr[i].isPlay) {
            continue
          }
          const element = this.videoStatusArr[i].result
          if (Object.keys(element).length === 0 || element.eventList.length === 0) {
            continue
          }
          element.newStartTime = newTime
          // console.log(this.$moment(element.newStartTime * 1000).format('YYYY-MM-DD HH:mm:ss'))
          let [status] = await openPlaybackList(this.pluginDom(i), element, false)
          if (status instanceof Object) {
            this.errorMsg(status.msg)
            return
          }
          if (status !== 0) {
            this.errorMsg('开流失败！')
            return
          }
          this.updateStatus(i, { isPlay: true })
        }
      } else {
        // 传了 只开一个
        let element = this.videoStatusArr[index].result
        element.newStartTime = newTime
        // console.log(this.$moment(element.newStartTime * 1000).format('YYYY-MM-DD HH:mm:ss'))
        let [status] = await openPlaybackList(this.pluginDom(index), element, false)
        if (status instanceof Object) {
          this.errorMsg(status.msg)
          return
        }
        if (status !== 0) {
          this.errorMsg('开流失败！')
        }
        this.updateStatus(index, { isPlay: true })
      }
      this.syncTime(this.playTime)
    },
    async structuringPlayback(data) {
      // 结构换追踪使用批量回放
      // 先初始化下数组
      this.matchingPane(data.length) // 根据当前数据匹配窗格数量
      this.initializeArr()
      // 注册消息回调
      this.playOverCallback = (index) => {
        console.log(index, 'fang  wanl')
        this.updateStatus(index, {isSyncPlay: true, isMiddlePlay: true})
      }
      this.middlePlayFatherStatus = true
      await this.openPlayback(data)
    },
    async clickOpenPlayback(data) {
      // 为业务管理 结果详情加  默认不播放 点击播放按钮播放
      data.forEach((item, index) => {
        this.updateStatus(index, {result: item, playStatus: true})
      })
    },
    async openPlayback(data, isQuery = true, womod) {
      this.stop()
      window.clearInterval(this.progressTimer)
      data = JSON.parse(JSON.stringify(data)) // 拷贝数据防止更改报错
      // 异步回放
      // isQuery 为 true 需要查询录像段， false 不需要查询录像段 直接调用插件
      // data = [{
      // "devIp": “设备IP,127.0.0.1”, // VMR通道
      // “devPort”:int//设备端口，
      // “channel”:int//设备通道
      //  eventType:['all']
      // "startTime": int,//开始时间
      // "endTime": int,//结束时间
      // "streamType":"",//码流类型（main,sub,）
      // "page": int,//当前第几页
      // "rows": int, //一页多少行,rows只能按1000的整数倍(由vmfs限制)
      // }]
      let playbackNumber = data.length
      if (data.length > this.checkedWmode) {
        this.errorMsg('无空闲窗口显示更多通道！')
        playbackNumber = this.checkedWmode
      }
      for (let i = 0; i < playbackNumber; i++) {
        let index = womod === undefined ? this.findFreePane() : womod
        this.checkedPane = index
        this.updateStatus(index, {
          isPlugin: true,
          playStatus: true,
          isButton: false,
          isPlay: false,
          isSyncPlay: false
        })
        this.$nextTick(async() => {
          // setTimeout(async() => {
          let [status, result] = await openPlaybackList(this.pluginDom(index), data[i], isQuery)
          if (status instanceof Object) {
            this.errorMsg(status.msg)
            return
          }
          if (status !== 0) {
            this.errorMsg('开流失败！')
            return
          }
          if (this.windowAdapter.length !== 0) {
            let timeId = setInterval(() => {
              let flag = this.plugin.plugin.SetPlayStretchBlt(...this.windowAdapter)
              if (flag === 1) {
                clearInterval(timeId)
              }
            }, 100)
          }
          this.pluginDom(index).SetStateCallback(() => {
            // 插件播放完成后的 回调
            this.updateStatus(index, { isPlay: false })
            this.pluginDom(index).CloseRecordPlay()
            this.playOverCallback(index)
            if (index === this.checkedPane) {
              // 关闭的是当前选中窗格
              this.progress = 0
              this.progressNow = this.formatTime(0)
              // window.clearInterval(this.progressTimer)
              this.$emit('playStatus', 2) // 1是暂停，2是停止, 3是播放
            }
          })
          this.updateStatus(index, { isPlay: true, result: result })
          this.$emit('playStatus', 3) // 1是暂停，2是停止, 3是播放
          if (this.configuration.progressBar) {
            // 调用插件播放时间 更改 进度条
            // if (result.occurrenceTime > result.startTime && result.occurrenceTime < result.endTime) {
            if (result.occurrenceTime) {
              this.occurrenceTimeLeft =
                ((result.occurrenceTime - result.startTime) / (result.endTime - result.startTime)) * 100 // 计算标记段位置
            }
            // }
          }
          if (this.configuration.timeline) {
            // 开流成功初始化时间轴
            this.initTimerShaft(result.startTime)
          }
          if (this.isSync) {
            let syncSetInterval = setInterval(() => {
              let time = parseInt(JSON.parse(this.pluginDom(index).GetRecordPlayerCurTime()).msCur / 1000)
              if (time !== 0) {
                this.syncTime(time)
                window.clearInterval(syncSetInterval)
              }
            }, 1000)
          } else {
            this.timer()
          }
          // }, 100)
        })
      }
    },
    async anewOpenPlayback(newTime, isQuery = false, paneMark) {
      /*
       *newTime  重新开流的播放时间
       *arr 重新开流的数组
       paneMark  重新开流窗格号
       */
      // 重新开溜  如果是停止或放完 就重新查录像段吧
      if (paneMark !== undefined) {
        this.checkedPane = paneMark
      }
      if (this.middlePlayFatherStatus) {
        this.updateStatus(this.checkedPane, {isSyncPlay: false, isMiddlePlay: false})
      }
      let result = this.videoStatusArr[this.checkedPane].result
      // result 是选中窗口上次查询录像段信息
      result.newStartTime = newTime
      // console.log(this.$moment(result.newStartTime * 1000).format('YYYY-MM-DD HH:mm:ss'))
      let [status] = await openPlaybackList(this.pluginDom(this.checkedPane), result, isQuery)
      if (status instanceof Object) {
        this.errorMsg(status.msg)
        return
      }
      if (status !== 0) {
        this.errorMsg('开流失败！')
      }
      this.updateStatus(this.checkedPane, { isPlay: true })
    },
    async sliderChange(value) {
      window.clearInterval(this.progressTimer)
      // 进度条快进触发
      // result 是选中窗口上次查询录像段信息
      let result = this.videoStatusArr[this.checkedPane].result
      let newTime = parseInt((result.endTime - result.startTime) * (value / 100) + result.startTime)
      await this.anewOpenPlayback(newTime)
      this.timer()
    },
    downloadVideo(data = [], isQuery = false, callback = () => {}) {
      this.getVideoConf() // 同步文件路径
      let dom = document.querySelector('#global-plugin')
      let download = []
      for (let index = 0; index < data.length; index++) {
        const element = data[index]
        if (!element.fileName) {
          element.fileName = `${this.parameters.downloadVideoPath}\\${element.name}_${this.$moment(new Date()).format('YYYYMMDDHHmmss')}.${this.parameters.downloadVideoType.toLowerCase()}`
        }
        download.push(downloadVideoSegments(dom, element, isQuery, callback))
      }
      return Promise.all(download)
    },
    downloadCallback(val) {
      for (const iterator of this.videoStatusArr) {
        if (Number(iterator.dumpHandle) === Number(val)) {
          iterator.dumpHandle = ''
        }
      }
    },
    openDownload() {
      if (!this.selectedObj.isPlay || this.selectedObj.dumpHandle) {
        return
      }
      this.downloadVideo([this.selectedObj.result], false, this.downloadCallback)
        .then(res => {
          res = JSON.parse(JSON.stringify(res))
          let err = ''
          res.forEach(item => {
            if (!item.success) {
              err += `${this.selectedObj.result.name}_`
            } else {
              this.selectedObj.dumpHandle = item.DumpHandle
            }
          })
          if (err !== '') {
            this.errorMsg(`${err}下载失败！`)
          } else {
            this.warningMsg(`录像开始下载, 下载路径为: ${this.selectedObj.result.fileName}`)
          }
        })
        .catch(err => {
          console.log(err)
        })
    },
    stopTimer() {
      // 判断是否全部停止播放 如果是停止定时器
      let isStopTimer = true
      for (const iterator of this.videoStatusArr) {
        if (iterator.isPlay) {
          isStopTimer = false
          break
        }
      }
      isStopTimer && window.clearInterval(this.progressTimer)
    },
    // 进度条 start
    timer() {
      // 进度条定时器
      // console.error('异步定时器怎么跑了')
      if (this.progressTimer) {
        // 新建定时器时先清除掉之前的定时器
        window.clearInterval(this.progressTimer)
      }
      this.progressTimer = setInterval(() => {
        // console.log(this.playTime, 'this.playTimethis.playTime')
        if (this.isOperation) {
          return
        } // 鼠标再操作时不对进度条赋值操作
        let checkedResult = this.videoStatusArr[this.checkedPane].result
        // 如果是对讲纯声音用 GetSpeechPlayerCurTime 获取时间
        let recordPlayerCurTime = checkedResult.dsServerId ? JSON.parse(this.pluginDom(this.checkedPane).GetSpeechPlayerCurTime()) : JSON.parse(this.pluginDom(this.checkedPane).GetRecordPlayerCurTime())
        let recordTime = parseInt(recordPlayerCurTime.msCur / 1000)
        // 若播放完了就将播放时间改为开始时间
        this.playTime = recordPlayerCurTime.success ? recordTime || this.playTime : checkedResult.startTime || 0
        if (this.configuration.timeline) {
          // 开流成功初始化时间轴
          this.moveDrawing()
        }
        if (this.configuration.progressBar.totalTime) {
          let result = this.selectedObj.result
          let time = result.endTime - result.startTime
          if (!isNaN(time)) {
            this.progressTotalTime = this.formatTime(time)
            let nowTime = this.playTime - result.startTime
            nowTime = nowTime < 0 ? 0 : nowTime
            this.progressNow = this.formatTime(nowTime)
          }
        }
        this.progress =
          ((this.playTime - checkedResult.startTime) / (checkedResult.endTime - checkedResult.startTime)) * 100
      }, 1000)
    },
    syncTime(time = this.playTime) {
      // console.warn('定时器调用次数11111111111111')
      // let time = newTime
      if (this.progressTimer) {
        // 新建定时器时先清除掉之前的定时器
        window.clearInterval(this.progressTimer)
        // console.warn(this.progressTimer, 'llll')
      }
      // console.log(time, 'timetime重新开流的时间轴时间')
      this.playTime = time
      // 初始化时间 同步
      // let timeNumeber = 10
      // console.log('syncTimesyncTimesyncTime')
      this.progressTimer = setInterval(() => {
        if (this.isOperation) {
          return
        } // 鼠标再操作时不对进度条赋值操作
        // console.log(this.playTime, time, '定时器时间同步')
        this.playTime++
        // console.log(this.playTime, time, '定时器时间同步')
        // console.log(this.playTime, 'syncTime.playTimethis.playTimethis.playTime')
        if (this.configuration.timeline) {
          // 绘制时间轴移动
          this.moveDrawing()
        }
        this.syncPlaybackMaintain()
      }, 1000)
    },
    sliderFormat() {
      return null
    },
    // 进度条 end
    // 单个时间轴 start
    moveDrawing() {
      Promise.all([timerShaft.moveDrawing(this.playTime), this.initSingleStage()])
    },
    initSingleStage() {
      if (!this.configuration.timeline) {
        return
      }
      // 时间轴下录像段条初始化
      let domWidth = document.querySelector('.segments').offsetWidth
      let timeScaleStaTime = this.playTime - this.timePeriod / 2
      let timeScaleEndTime = this.playTime + this.timePeriod / 2
      let sumTime = timeScaleEndTime - timeScaleStaTime
      let secondPx = domWidth / sumTime
      // 计算单个时间轴上 各个路线段的位置
      let resultArr = []
      for (let index = 0; index < this.videoStatusArr.length; index++) {
        let item = this.videoStatusArr[index]
        if (item.playStatus && Object.keys(item.result).length !== 0) {
          // 必需要有录像段
          item = item.result
          if (item.endTime < timeScaleStaTime || item.startTime > timeScaleEndTime || item.eventList.length === 0) {
            continue
          } // 如果该时间段不在时间轴范围
          item.eventList.forEach(video => {
            resultArr.push({
              left: `${((video.evtTblInfo.startTime - timeScaleStaTime) / sumTime) * 100}%`,
              width: `${(video.evtTblInfo.endTime - video.evtTblInfo.startTime) * secondPx}px`,
              bgc: this.colorArr[index]
            })
          })
        }
      }
      this.singleStage = JSON.parse(JSON.stringify(resultArr))
    },
    initTimerShaft(time = this.playTime) {
      if (!this.configuration.timeline) {
        return
      }
      // 根据传入时间初始化时间轴 传入时间为时间轴中间时间
      // console.log(time, this.playTime, 'playTimeplayTime')
      timerShaft.init(
        document.querySelector('#time-scale'),
        this.$moment,
        time * 1000,
        this.timePeriod,
        '.timeline-stage-bottom'
      ) // 时间轴初始化
      timerShaft.mousemoveCallback = (val, centralTime) => {
        // 时间轴滑动触发
        this.isOperation = true
        this.playTime = parseInt(centralTime)
        this.initSingleStage()
        // this.anewOpenPlayback(this.playTime)
        // console.log(centralTime, val, 9999999)
      }
      timerShaft.moveOver = async time => {
        // console.log('滑动后触发')
        // this.playTime = time

        if (this.isSync) {
          // console.log(this.playTime, '重新开流的时间轴时间')
          this.anewSyncOpenPlayback(this.playTime)
        } else {
          this.anewOpenPlayback(this.playTime)
        }
        this.isOperation = false
        // console.log('滑动后触发')
      }
    },
    intervalChange(val, index) {
      if (!index) {
        // 时间刻度区间改变
        let newInterval = this.interval
        if (val) {
          this.interval > 0 && this.interval--
        } else {
          this.interval < this.intervalArr.length - 1 && this.interval++
        }
        if (newInterval === this.interval) {
          return
        }
      } else {
        this.interval = index
      }
      this.timePeriod = this.intervalArr[this.interval].value
      // this.initTimerShaft() // 更改周期 初始化时间轴
      Promise.all([this.initSingleStage(), this.initTimerShaft()])
    }
    // 单个时间轴 end
  },
  beforeDestroy() {
    window.clearInterval(this.progressTimer)
  }
}
</script>
<style lang="less">
.video-plugin {
  .ivu-progress-success .ivu-progress-bg {
    background-color: rgb(32, 161, 255);
  }
}
</style>
<style lang="less" scoped>
.fs {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  width: 100% !important;
  height: 100% !important;
}
.video-plugin {
  position: relative;
  z-index: 999999;
  .disabled {
    color: hsla(0, 0%, 100%, 0.5);
    cursor: not-allowed !important;
  }
  background-color: #404040;
  width: 100%;
  height: 100%;
  .single-video-plugin {
    position: relative;
    overflow: hidden;
    box-sizing: border-box;
    width: 100%;
    font-size: 0px;
    .shade-iframe {
      width: 100%;
      height: 100%;
      background-color: #404040;
      border: 0px;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 999;
    }
    .hide {
      position: absolute;
      left: 9999px;
      top: -9999px;
      z-index: 999;
    }
    .maximize {
      width: 100% !important;
      height: 100%;
    }
    .active {
      border-color: #4699f9;
    }
  }
  .video-bottom {
    overflow: hidden;
    width: 100%;
    height: 56px;
    background-color: #1b3153;
    .left,
    .right {
      float: left;
      width: 50%;
      height: 100%;
    }
    .right {
      text-align: right;
      position: relative;
      padding: 0 8px;
      i {
        padding: 0 4px;
        cursor: pointer;
        font-size: 20px;
      }
      .progress-bar {
        width: 80%;
        height: 16px;
        position: absolute;
        bottom: 16px;
        transform: translate(0, -50%);
        z-index: 999;
        .play-time {
          position: absolute;
          left: 50%;
          transform: translate(0, -50%);
        }
        .occurrence-time {
          position: absolute;
          width: 10%;
          height: 4px;
          bottom: -6px;
          border-radius: 2px;
          display: inline-block;
          background-color: red;
          transform: translate(-50%, -50%);
          z-index: 1;
        }
        .slide-mon-f {
          width: 100%;
          position: relative;
          z-index: 999;
          opacity: 0.5;
        }
        .total-time {
          position: absolute;
          width: 20px;
          top: -5px;
          right: 84px;
          white-space: nowrap;
        }
      }
      .dp-con {
        // float: right;
        // line-height: 56px;
        // padding: 0 8px;
        padding: 0 8px;
        line-height: 56px;
        position: relative;
        display: inline-block;
        i {
          cursor: pointer;
          font-size: 20px;
        }
        ul {
          position: absolute;
          background-color: #335589;
          position: absolute;
          list-style: none;
          bottom: 12px;
          color: snow;
          text-align: center;
          background: #335589;
          height: 40px;
          padding: 0 12px;
          border-radius: 4px;
          i {
            display: block;
            position: absolute;
            background: #335589;
            width: 14px;
            height: 14px;
            transform: rotate(45deg);
            top: 13px;
            right: -5px;
          }
          li {
            line-height: 40px;
          }
          .active {
            color: #fda54b;
          }
        }
        li:hover {
          color: #fda54b;
          cursor: pointer;
          margin: 2px 0;
        }
      }
      .showmodeShow {
        .showmode-list {
          position: absolute;
          list-style: none;
          bottom: 12px;
          height: 40px;
          text-align: center;
          padding: 0 6px;
          border-radius: 4px;
          right: 45px;
          white-space: nowrap;
          line-height: 40px;
          li {
            position: relative;
            z-index: 99;
            display: inline-block;
            white-space: nowrap;
            padding: 0 8px;
            border-right: 1px solid hsla(0, 0%, 100%, 0.1);
          }
        }
      }
    }
    .left {
      line-height: 56px;
      i {
        padding: 0 4px;
        cursor: pointer;
        font-size: 20px;
      }
    }
  }
  .video-timeline {
    width: 100%;
    .one-stage {
      width: 100%;
      height: 100%;
      .timeline-stage-top {
        width: 100%;
        height: 32px;
        background: #0c1b32;
        line-height: 32px;
        position: relative;
        .play-time {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
        }
        .stage-top-right {
          float: right;
          .period {
            float: right;
            i {
              cursor: pointer;
            }
            span {
              width: 36px;
              display: inline-block;
              text-align: center;
              margin: 0 4px;
            }
          }
        }
      }
      .timeline-stage-bottom {
        width: 100%;
        height: ~'calc(100% - 32px)';
        background-color: #1c3053;
        cursor: pointer;
        .timeline-scale {
          position: relative;
          width: 100%;
          height: 40px;
          #time-scale {
            position: absolute;
          }
          .pointer {
            position: absolute;
            width: 9px;
            height: 13px;
            top: 33px;
            left: 50%;
            transform: translate(0, -50%);
            background-color: #f78930;
            border-bottom-left-radius: 30px;
            border-bottom-right-radius: 30px;
            z-index: 99999;
            .pointer-line {
              width: 1px;
              height: 32px;
              background-color: #f78930;
              margin: 9px auto 0;
            }
          }
        }
        .timeline-video-segments {
          width: 100%;
          height: ~'calc(100% - 40px)';
          position: relative;
          .segments {
            overflow: hidden;
            width: 100%;
            height: 12px;
            background-color: #3b5074;
            margin: auto 0;
            position: absolute;
            top: 50%;
            transform: translate(0, -50%);
            .segments-son {
              position: absolute;
              height: 100%;
            }
          }
        }
      }
    }
  }
}
</style>
